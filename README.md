# 傳統優化演算法比較專案

這是一個使用 Python 進行的數值優化專案，旨在比較兩種經典的傳統優化演算法——**Nelder-Mead (單純形法)** 和 **Simulated Annealing (模擬退火)**——在解決不同特性測試函數時的性能表現。

## 核心概念

本專案透過在兩種截然不同的測試函數上應用這兩種演算法，來探索它們的優缺點、收斂能力和對複雜問題的魯棒性。

### 測試函數

1.  **Sphere Function (球狀函數)**
    * **特性**: 一個簡單、凸、單峰（unimodal）的函數。其全局最小值位於座標原點 (0, 0, ..., 0)，沒有局部最小值。
    * **挑戰**: 主要用於測試演算法的基本收斂速度和精度。對於梯度下降等方法來說非常容易解決。

2.  **Schwefel Function (施韋費爾函數)**
    * **特性**: 一個複雜、非凸、多峰（multimodal）的函數，具有大量的局部最小值。
    * **挑戰**: 其全局最小值（接近 0）位於搜索空間的邊界附近，且與次優的局部最小值距離很遠。這對演算法的全局搜索能力和避免陷入局部最優的能力構成了嚴峻的考驗。

### 優化演算法

1.  **Nelder-Mead (單純形法)**
    * **類型**: 局部搜索、無梯度（derivative-free）演算法。
    * **原理**: 透過在解空間中維護一個單純形（simplex），並通過反射、擴張、壓縮和收縮等操作來迭代地移動和變形這個單純形，從而逐步逼近最小值。
    * **優點**: 不需要計算梯度，實現相對簡單。
    * **缺點**: 容易陷入局部最小值，對於高維度或複雜問題可能效率不高。

2.  **Simulated Annealing (模擬退火)**
    * **類型**: 啟發式、隨機搜索演算法。
    * **原理**: 模擬物理退火過程。演算法在搜索過程中會以一定的機率接受一個比當前解更差的解，這個機率會隨著「溫度」的降低而減小。這種機制使其有能力跳出局部最小值，進行全局搜索。
    * **優點**: 具有強大的全局搜索能力，理論上可以找到全局最優解。
    * **缺點**: 收斂速度通常較慢，且需要仔細調整初始溫度、降溫速率等超參數。

## 檔案說明

本專案包含五個主要的 Python 腳本。

* `nm_sin.py`: 使用 **Nelder-Mead** 演算法來最小化 **Sphere** 函數。
* `sa_sim.py`: 使用 **Simulated Annealing** 演算法來最小化 **Sphere** 函數。
* `nm_mul.py`: 使用 **Nelder-Mead** 演算法來最小化 **Schwefel** 函數。
* `sa_mul.py`: 使用 **Simulated Annealing** 演算法來最小化 **Schwefel** 函數。
* `test.py`: 一個簡單的測試腳本，用於計算並驗證 **Schwefel** 函數在理論最優點 `[420.97, ..., 420.97]` 的值。

## 環境依賴

您需要安裝以下 Python 函式庫才能執行此專案。建議在虛擬環境中進行安裝。

```bash
pip install numpy matplotlib scipy
```

## 如何執行

您可以獨立執行任何一個優化腳本來觀察其過程和結果。

```bash
# 使用 Nelder-Mead 優化 Sphere 函數
python nm_sin.py

# 使用 Simulated Annealing 優化 Sphere 函數
python sa_sim.py

# 使用 Nelder-Mead 優化 Schwefel 函數
python nm_mul.py

# 使用 Simulated Annealing 優化 Schwefel 函數
python sa_mul.py
```

## 視覺化結果

每個優化腳本在執行完畢後，都會生成一個 3D 視覺化圖表，展示：

1.  **目標函數的 3D 表面**: 繪製出目標函數在二維空間的 3D 曲面圖，讓您直觀地了解函數的地形。
2.  **搜索歷史**: 將演算法在迭代過程中所訪問過的點（或接受的點）標示在函數表面上。
3.  **最佳解**: 將演算法找到的最佳解用突出的標記（紅色三角形）標示出來。

透過這些圖表，您可以直觀地比較不同演算法在不同函數上的搜索路徑和最終收斂效果。
